\documentclass{beamer}

\usetheme{CambridgeUS}
\usecolortheme{dolphin}

\title{Verteilte Systeme}
\subtitle{Architekturparadigmen und Entwurfsmuster}
\author{Prof. Dr. Martin Becke}
\date{\today}


\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Schichtenarchitektur (Layered Architecture)}
    Die Schichtenarchitektur ist ein grundlegendes Architekturmuster, das Systeme in mehrere Schichten unterteilt, wobei jede Schicht eine bestimmte Funktion erfüllt und auf der darunterliegenden Schicht aufbaut.  Wie ein mehrstöckiges Gebäude: Jede Etage hat eine spezifische Funktion (Wohnen, Arbeiten, Schlafen) und baut auf der darunterliegenden Etage auf.
\end{frame}


\begin{frame}{Schichten vs. Ebenen (Layers vs. Tiers)}
    \textbf{Layer (Schicht):} Logische Gruppierung von Funktionen innerhalb einer Anwendung.

    \textbf{Tier (Ebene):}  Physische oder logische Aufteilung von Anwendungen auf verschiedene Server oder Geräte.

    Ein Layer kann aus mehreren Tiers bestehen.  Beispiel: Eine dreischichtige Architektur (Präsentation, Anwendung, Daten) kann auf drei verschiedenen Servern (Client, Anwendungsserver, Datenbank) implementiert werden.
\end{frame}


\begin{frame}{Single-Node-Architektur}
    Die Single-Node-Architektur beschreibt Systeme, die auf einem einzigen Knoten ausgeführt werden.  Sie ist die einfachste Form eines verteilten Systems (1-Tier-Architektur) und eignet sich für kleine Anwendungen oder für die Entwicklung und das Testen.  Wie ein einzelner Musiker:  Er kann alleine ein einfaches Musikstück spielen, aber für komplexere Stücke benötigt er ein Orchester (mehrere Knoten).
\end{frame}


\begin{frame}{Middleware}
    Middleware ist eine Softwareschicht, die zwischen Anwendung und Betriebssystem liegt und die Kommunikation und Interaktion zwischen verschiedenen Komponenten oder Systemen in einem verteilten System vereinfacht. Sie bietet Dienste wie Kommunikationsprotokolle, Datenkonvertierung, Namensauflösung und Sicherheit.  Wie ein Dolmetscher:  Er übersetzt zwischen verschiedenen Sprachen und ermöglicht die Kommunikation zwischen Menschen, die unterschiedliche Sprachen sprechen.
\end{frame}


\begin{frame}{Client-Server-Architektur}
    Die Client-Server-Architektur teilt ein System in Clients, die Dienste anfordern, und Server, die diese Dienste bereitstellen.  Wie ein Restaurant:  Die Gäste (Clients) bestellen Essen, und die Küche (Server) bereitet es zu.  Diese Architektur ist weit verbreitet und bildet die Grundlage für viele Anwendungen im Internet.

    \textbf{Varianten:} Thin Client, Thick Client, Hybrid Client.
\end{frame}

\begin{frame}{n-Tier-Architektur und Kaskadenkommunikation}
    Die n-Tier-Architektur erweitert das Client-Server-Modell, indem sie die Anwendung in mehrere Ebenen (Tiers) unterteilt. Diese Ebenen können auf verschiedenen Servern oder Maschinen laufen und über das Netzwerk miteinander kommunizieren. Eine häufige Form ist die 3-Tier-Architektur (Präsentation, Anwendung, Daten).  Die kaskadenartige Kommunikation zwischen den Tiers kann zu Latenzproblemen und erhöhter Komplexität führen.
\end{frame}


\begin{frame}{Stub/Skeleton Chains}
    In einer n-Tier-Architektur werden oft Stubs und Skeletons verwendet, um die Kommunikation zwischen den Schichten zu vereinfachen. Ein Stub ist ein Platzhalter für einen entfernten Methodenaufruf, während ein Skeleton die Implementierung auf der Serverseite bereitstellt.  Wie ein Telefonanruf:  Der Anrufer (Stub) wählt die Nummer und spricht mit dem Angerufenen (Skeleton).
\end{frame}


\begin{frame}{Event-Driven Architektur (EDA)}
    In der EDA kommunizieren die Komponenten durch den Austausch von Ereignissen (Events). Komponenten reagieren auf Ereignisse, anstatt direkt miteinander zu interagieren.  Wie ein Nachrichtensystem:  Abonnenten (Komponenten) erhalten Nachrichten (Events) zu bestimmten Themen.  Diese Architektur fördert lose Kopplung und Skalierbarkeit.
\end{frame}

\begin{frame}{Lambda-Architektur}
    Die Lambda-Architektur wird oft in Kombination mit EDA verwendet, um große Datenmengen in Echtzeit und im Batch-Modus zu verarbeiten.  Sie besteht aus drei Schichten: Batch Layer (für historische Daten), Speed Layer (für Echtzeitdaten) und Serving Layer (für Abfragen und Analysen).  Wie ein Nachrichtenarchiv:  Alte Nachrichten werden im Archiv (Batch Layer) gespeichert, neue Nachrichten werden sofort verarbeitet (Speed Layer) und Benutzer können auf alle Nachrichten zugreifen (Serving Layer).
\end{frame}


\begin{frame}{Microservices-Architektur}
    Die Microservices-Architektur unterteilt eine Anwendung in kleine, unabhängige Services, die jeweils eine bestimmte Geschäftsfunktion ausführen.  Wie ein Team von Spezialisten:  Jeder Spezialist (Microservice) ist für einen bestimmten Bereich verantwortlich.  Diese Architektur fördert Flexibilität, Wartbarkeit und Skalierbarkeit, erhöht aber auch die Komplexität.
\end{frame}


\begin{frame}{Peer-to-Peer-Architektur (P2P)}
    In der P2P-Architektur kommunizieren die Knoten (Peers) direkt miteinander, ohne dass ein zentraler Server erforderlich ist.  Wie ein Tauschring:  Die Teilnehmer (Peers) tauschen direkt untereinander Ressourcen aus. Diese Architektur ist robust, skalierbar und fehlertolerant, kann aber auch Herausforderungen bei der Sicherheit und der Suche nach Ressourcen mit sich bringen.
\end{frame}



\begin{frame}{Hexagonale Onion Architektur}
    Die Hexagonale Onion Architektur kombiniert die Prinzipien der Hexagonalen Architektur (Ports and Adapters) und der Zwiebelarchitektur (Clean Architecture). Sie zielt darauf ab, die Kernlogik der Anwendung von externen Abhängigkeiten zu trennen und die Testbarkeit, Wartbarkeit und Erweiterbarkeit zu verbessern.  Wie eine Zwiebel:  Die Kernlogik (Entities) liegt im Zentrum, umgeben von Schichten für Anwendungslogik (Use Cases), Ports und Adapter sowie Infrastruktur.
\end{frame}



\begin{frame}{Zeitgesteuert vs. Ereignisgesteuert (Time-Triggered vs. Event-Triggered)}
    \textbf{Zeitgesteuert:} Aktionen werden nach einem festen Zeitplan ausgeführt. Wie ein Uhrwerk:  Es tickt in regelmäßigen Intervallen.

    \textbf{Ereignisgesteuert:}  Aktionen werden durch Ereignisse ausgelöst. Wie ein Lichtschalter:  Er reagiert auf das Drücken des Schalters.
\end{frame}


\begin{frame}{Entwurfsmuster (Design Patterns) - Überblick}
Entwurfsmuster sind bewährte Lösungen für wiederkehrende Probleme in der Softwareentwicklung. Sie bieten wiederverwendbare Blaupausen für die Gestaltung von Code und die Interaktion zwischen Objekten und Klassen. Einige wichtige Entwurfsmuster in verteilten Systemen sind:  Singleton, Observer, Factory Method, Adapter.
\end{frame}


\begin{frame}{Model-View-Controller (MVC)}
    MVC trennt eine Anwendung in drei Komponenten:
    \begin{itemize}
        \item \textbf{Model:}  Daten und Geschäftslogik.
        \item \textbf{View:}  Präsentation und Benutzerinteraktion.
        \item \textbf{Controller:}  Steuerung und Koordination.
    \end{itemize}
    MVC fördert die Trennung von Anliegen und verbessert die Wartbarkeit und Testbarkeit.  Wie ein Theaterstück: Das Drehbuch (Model), die Schauspieler (View) und der Regisseur (Controller) arbeiten zusammen.
\end{frame}


\begin{frame}{CVM und VCM}
    CVM (Controller-View-Model) und VCM (View-Controller-Model) sind Variationen des MVC-Musters, die die Reihenfolge der Komponenten im Schichtenmodell verändern.  Sie sind keine eigenständigen Muster, sondern eher spezielle Ausprägungen von MVC.
\end{frame}


\begin{frame}{Vertreter (Proxy)}
    Ein Proxy ist ein Stellvertreter für ein anderes Objekt oder einen anderen Dienst.  Er kontrolliert den Zugriff auf das eigentliche Objekt und kann zusätzliche Funktionen wie Caching oder Sicherheit bieten.  Wie ein Türsteher: Er kontrolliert den Zugang zum Club.  Proxies sind nützlich, um die Komplexität von verteilten Systemen zu verbergen und die Leistung zu verbessern.

    \textbf{Arten:} Forward Proxy, Reverse Proxy, Caching Proxy, Load Balancing Proxy.
\end{frame}



\end{document}
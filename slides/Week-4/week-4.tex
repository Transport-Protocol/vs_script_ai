\documentclass{beamer}

\usetheme{CambridgeUS}
\usecolortheme{dolphin}

\title{Verteilte Systeme}
\subtitle{Architekturparadigmen und Entwurfsmuster}
\author{Prof. Dr. Martin Becke}
\date{\today}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Architekturmuster}
    \textbf{Definition:} Beschreiben die grundlegende Organisation eines Softwaresystems.
    \begin{itemize}
        \item Strukturierung großer Systemkomponenten
        \item Definieren von Kommunikationswegen und Datenflüssen
    \end{itemize}
    \textbf{Reflexionsfrage:} Warum sind Architekturmuster für skalierbare Systeme wichtig?
\end{frame}

\begin{frame}{Schichtenarchitektur}
    \textbf{Prinzip:} Aufteilung in Schichten mit spezifischen Funktionen.

    \begin{itemize}
        \item Trennung von Präsentation, Logik und Datenhaltung
        \item Verbesserte Wartbarkeit und Skalierbarkeit
    \end{itemize}
    \textbf{Analogie:} Ein Gebäude mit Etagen – jede Schicht hat eine Funktion.
\end{frame}

\begin{frame}{Middleware}
    \textbf{Definition:} Vermittelt zwischen Anwendung und Betriebssystem.
    \begin{itemize}
        \item Erleichtert Kommunikation zwischen verteilten Systemen
        \item Bietet Dienste wie Sicherheit, Namensauflösung
    \end{itemize}
    \textbf{Diskussionsfrage:} Wie kann Middleware helfen, heterogene Systeme zu verbinden?
\end{frame}

\begin{frame}{Client-Server-Architektur}
   
    \textbf{Prinzip:} Clients fordern Dienste von Servern an.
    \textbf{Beispiel:} Restaurant (Gäste bestellen, Küche bereitet Essen zu).
    \textbf{Varianten:}
    \begin{itemize}
        \item Thin Client – Logik auf Server
        \item Thick Client – Logik auf Client
        \item Hybrid Client – Mischung aus beidem
    \end{itemize}
\end{frame}

\begin{frame}{n-Tier-Architektur}
    \textbf{Prinzip:} Mehrstufiges Client-Server-Modell.
    \begin{itemize}
        \item Klare Trennung von Präsentation, Logik, Datenbank
        \item Erhöhte Modularität, aber komplexere Kommunikation
    \end{itemize}
    \textbf{Reflexionsfrage:} Wann ist eine 5-Tier-Architektur sinnvoll?
\end{frame}

\begin{frame}{Microservices-Architektur}
    \textbf{Prinzip:} Kleine, unabhängige Dienste mit klaren Schnittstellen.
    \textbf{Diskussion:}
    \begin{itemize}
        \item Skalierbarkeit
        \item Unabhängige Entwicklung
        \item Höhere Komplexität
    \end{itemize}
\end{frame}

\begin{frame}{Event-Driven Architektur (EDA)}
    \textbf{Prinzip:} Komponenten reagieren auf Ereignisse.
    \textbf{Beispiel:} Nachrichtensystem – Abonnenten erhalten Updates.
    \textbf{Vorteile:}
    \begin{itemize}
        \item Hohe Entkopplung
        \item Gute Skalierbarkeit
    \end{itemize}
\end{frame}

\begin{frame}{Function as a Service (FaaS)}
    \textbf{Definition:} 
    \begin{itemize}
        \item FaaS ist ein Cloud-Computing-Modell, bei dem Anwendungen als einzelne, ausführbare Funktionen bereitgestellt werden.
        \item Entwickler schreiben Code, ohne sich um die zugrunde liegende Infrastruktur kümmern zu müssen.
    \end{itemize}
    Cloud First
\end{frame}    

\begin{frame}{Diskussion: Womit starten?}
    \textbf{Thema:} Schichtenarchitektur vs. Microservices.
    \textbf{Diskussionsfrage:} Wann ist welche Architektur vorteilhaft?
\end{frame}

\end{document}